# 设计原则
- 找出应用中可能需要改变之处，把他独立出来，不要和那些不需要变化的代码混在一起
- 针对接口编程，而不是针对实现编程
- 多用组合，少用继承
- 为了交互对象之间额松耦合设计而努力
- 类应该对扩展开放，对修改关闭
- 要依赖抽象，不要依赖具体类
- 最少知识原则：只与你的密友谈话
— 好莱坞原则：别调用(打电话给)我们，我们会调用(打电话给)你。
- 单一责任：一个类应该只有一个引起变化的原因
# 目录
- one 策略模式
> 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
- two 观察者模式
> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖着都会通知并自动更新。
- three 装饰者模式
> 动态的将责任附加到对象上。若要扩展功能，装饰着提供了比继承更有弹性的替代方案。
- four 工厂模式  
    - 工厂方法模式
    > 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
    - 抽象工厂模式
    > 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
- five 单件模式
> 确保一个类只有一个实例，并提供一个全局访问点。
- six 命令模式
> 将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销操作。
- seven 适配器模式
> 将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
- eight 外观模式
> 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
- nine 模板方法模式
> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
- ten 迭代器模式
> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
- eleven 组合模式
> 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
- twelve 状态模式
> 允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它的类。
- thirteen 代理模式
> 为另一个对象提供一个替身或占位符以控制对这个对象的访问。
- fourteen 复合模式
> 结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。
- fifteen 桥接模式
> 不只改变你的实现，也改变你的抽象，将抽象部分与它的实现部分分离，使它们都可以独立地变化
- sixteen 生成器模式
> 将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示
- seventeen 责任链模式
> 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- eighteen 蝇量模式
> 它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。
- nineteen 解释器模式
> 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。
- twenty 中介者模式
> 用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- twenty one 备忘录模式
> 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
- twenty two 原型模式
> 通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例
- twenty three 访问者模式
> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。